Chapter 1 – things to think about
When importing a class with the same name from two different packages using an import statement the second of those import statements will cause a failure to compile. The compiler will see it as ambiguous and won’t know how to resolve the class when used by its simple name. This can be resolved by using the fully qualified name in the class.
Protected members of a base class cannot be accessed using a reference variable of the base class within the derived class when the base class and the derived classes are in different packages. Any attempt to do so will cause the derived class to fail compilation.
When asked which options will cause a ClassCastException they must first compile because ClassCastException is a runtime exception. All those that don’t compile can be excluded. Those that have an inheritance hierarchy can be explicitly cast and those that are derived classes being cast to base classes will throw a ClassCastException. It is possible to cast any instance of a nonfinal class to any interface type and only at runtime will the JVM determine whether the class has an inheritance relationship with the interface. In the event it doesn’t then a ClassCastException is thrown.
A class that implements an inefficient hashcode method can still be used as keys even if an equals method is not implemented. This is because the default implementation of the equals method will compare the reference variables and retrieve the objects using this.

